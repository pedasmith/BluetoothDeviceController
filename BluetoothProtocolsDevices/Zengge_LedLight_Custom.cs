using BluetoothProtocols;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Windows.Devices.Bluetooth.GenericAttributeProfile;
using Windows.UI.Xaml.Controls;

namespace BluetoothProtocols
{

    public struct HSV
    {
        public byte H;
        public byte S;
        public byte V;

        public HSV(byte h, byte s, byte v)
        {
            H = h;
            S = s;
            V = v;
        }

        public static HSV RgbToHsv(int r, int g, int b)
        {
            double rNorm = r / 255.0;
            double gNorm = g / 255.0;
            double bNorm = b / 255.0;

            double max = Math.Max(rNorm, Math.Max(gNorm, bNorm));
            double min = Math.Min(rNorm, Math.Min(gNorm, bNorm));
            double delta = max - min;

            double h = 0;
            if (delta != 0)
            {
                if (max == rNorm)
                {
                    h = 60 * (((gNorm - bNorm) / delta) % 6);
                }
                else if (max == gNorm)
                {
                    h = 60 * (((bNorm - rNorm) / delta) + 2);
                }
                else if (max == bNorm)
                {
                    h = 60 * (((rNorm - gNorm) / delta) + 4);
                }
            }

            double s = (max == 0) ? 0 : delta / max;
            double v = max;

            if (h < 0)
            {
                h += 360;
            }

            return new HSV((byte)(h/2.0), (byte)(s*100.0), (byte)(v*100));
        }

    }


    /*
    Generated by AI!

    Explanation:
    Normalization: The RGB values are normalized by dividing by 255.
    Max and Min: The maximum and minimum values among the normalized RGB values are found.
    Delta: The difference between the max and min values.
    Hue Calculation: The hue is calculated based on which color channel is the maximum.
    Saturation Calculation: The saturation is calculated as the ratio of the delta to the max value.
    Value Calculation: The value is simply the max value.
    Adjust Hue: If the hue is negative, 360 is added to ensure it is within the range[0, 360].

    Feel free to adapt this code to fit your specific needs!
    */
    public partial class Zengge_LedLight : Light
    {
        byte Counter = 0;

        public override Capability GetDeviceCapability()
        {
            var retval = Capability.OnOff | Capability.SetBrightness | Capability.SetWarm | Capability.SetColorRGB;
            return retval;
        }
        byte lastWarmth = 0x44; // arbitrary value
        byte lastBrightness = 0x77; // arbitrary value

        enum CMD : byte
        {
            POWER_ON = 0x23,
            POWER_OFF = 0x24,
            SET_RGB = 0xA1,
            SET_WHITE = 0xB1,
        };
        public override async Task<GattCommunicationStatus> SetBrightnessAsync(double value)
        {
            byte brightness = (byte)(value * 100.0);
            lastBrightness = brightness;
            var result = await WriteLED_Write(0x00, Counter, 0x80, 0x00, 0x000d, 0x0e, 0x0b3b, (byte)CMD.SET_WHITE, 0x00, 0x00, 0x00, lastWarmth, brightness, new byte[6] { 0, 0, 0, 0, 0, 0 });
            return result;
        }
        public override async Task<GattCommunicationStatus> SetRGBAsync(byte R, byte G, byte B)
        {
            HSV hsv = HSV.RgbToHsv(R, G, B);
            var result = await WriteLED_Write(0x00, Counter, 0x80, 0x00, 0x000d, 0x0e, 0x0b3b, (byte)CMD.SET_RGB, hsv.H, hsv.S, hsv.V, 0x00, 0x00, new byte[6] { 0, 0, 0, 0, 0, 0 });
            return result;
        }
        public override async Task<GattCommunicationStatus> SetWarmthAsync(double value)
        {
            // Input: warmth is 0(blue/cold) to 1.0 (red/warm). The Zenggee is temperature: 0=lower temp/red = "warmer" to 100 higher temp/bluer = "colder"
            byte warmth = (byte)((1.0-value) * 100.0);
            lastWarmth = warmth;
            var result = await WriteLED_Write(0x00, Counter, 0x80, 0x00, 0x000d, 0x0e, 0x0b3b, (byte)CMD.SET_WHITE, 0x00, 0x00, 0x00, warmth, lastBrightness, new byte[6] { 0, 0, 0, 0, 0, 0 });
            return result;
        }

        public override async Task<GattCommunicationStatus> TurnOnOffAsync(bool On)
        {
            byte cmd = (byte)(On ? CMD.POWER_ON : CMD.POWER_OFF);
            var result = await WriteLED_Write(0x00, Counter, 0x80, 0x00, 0x000d, 0x0e, 0x0b3b, cmd, 0x00, 0x00, 0x00, 0x00, 0x00, new byte[6] { 0, 0, 0, 0, 0, 0 });
            return result;
        }
    }
}
